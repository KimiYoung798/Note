# Chapter_1_引论

## 1.1 本书讨论内容
写出一个可以工作的程序并不够，***运行时间和运行所占空间***，都需要进行考虑优化。
## 1.2 数学知识复习

### 1.2.1 指数

> $X^AX^A = X^{A+B}$
> $\frac{X^A}{X^A} = X^{A-B}$
> ${(X^A)}^B = X^{AB}$
> $X^N+X^N = 2X^N \not ={X^{2N}}$

### 1.2.2 对数
在计算机科学中，除非有特别声明，所有的对数都是以2为底。
**定义**：当前仅当$log_X{B}=A$，$X^A = B$。

> **定理1.1**
>   $log_AB = \frac{log_CB}{log_CA};C>0$
> **定理1.2**
>   $logAB = logA+logB$

### 1.2.3 级数

### 1.2.4 模运算

若N整除A-B，那么A与B模N同余(congruent)，记为$A\models B(mod N)$，直观的看，这意味着无论A还是B除以N，多的余数都是相同的。

### 1.2.5 证明方法
**归纳法证明**
**通过反例证明**

## 1.3 递归简论
**递归的四条准本准则**
> 1. 基准情形(base case)。必须又某些基准的情形，他们不用递归就能求解
> 2. 不断推进(making progress)。对于需要递归求解的情形，递归调用必须能够朝着生产基准情形的方向推进。
> 3. 设计法则(design rule)。假设所有的递归调用都能运行。
> 4. 合成效益法则(compound interest rule)。求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。
___
# Chapter_2_算法分析

## 2.1 数学基础

## 2.2 模型

## 2.3 要分析的问题

## 2.4 运行时间计算
### 2.4.1 一个简单的例子
### 2.4.2 一般法则
### 2.4.3 最大子序列和
### 2.4.4 运行时间中的对数
### 2.4.5 检验你的分析
### 2.4.6 分析结果的准确性
___
# Chapter_3_表、栈、队列
___
# Chapter_4_树
___
# Chapter_5_散列
___
# Chapter_6_优先队列（堆）
___
# Chapter_7_排序
___
# Chapter_8_不相交集ADT
___
# Chapter_9_图论算法
___
# Chapter_10_算法设计技巧
___
# Chapter_11_摊还分析
___
# Chapter_10_高级数据结构及其实现
___